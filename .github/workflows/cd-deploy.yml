name: CD - Deploy & Release

on:
  workflow_dispatch:
    inputs:
      service:
        description: "Service √† d√©ployer (api-gateway, frontend, order-service, product-service, all)"
        required: true
        default: "all"
        type: choice
        options:
          - api-gateway
          - frontend
          - order-service
          - product-service
          - all
      bump_type:
        description: "Type de version bump (patch, minor, major)"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major

env:
  REGISTRY: ghcr.io
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # D√©terminer les services √† d√©ployer
  determine-services:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-services.outputs.services }}
    steps:
      - name: "üìã D√©terminer les services"
        id: set-services
        run: |
          if [ "${{ github.event.inputs.service }}" = "all" ]; then
            echo "services=api-gateway,frontend,order-service,product-service" >> $GITHUB_OUTPUT
          else
            echo "services=${{ github.event.inputs.service }}" >> $GITHUB_OUTPUT
          fi

  # CodeQL - Scan de s√©curit√©
  security-scan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ["api-gateway", "frontend", "order-service", "product-service"]
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Initialiser CodeQL"
        uses: github/codeql-action/init@v2
        with:
          languages: javascript

      - name: "Lancer analyse CodeQL"
        uses: github/codeql-action/analyze@v2

  # Build & Push - Construire et pusher les images Docker
  build-and-push:
    needs: [determine-services, security-scan]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(format('[{0}]', needs.determine-services.outputs.services)) }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Login to Container Registry"
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: "Setup Docker Buildx"
        uses: docker/setup-buildx-action@v2

      - name: "Extract metadata"
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: "Build et push Docker image"
        uses: docker/build-push-action@v4
        with:
          context: ./${{ matrix.service }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Version Bump & Changelog
  version-and-changelog:
    needs: determine-services
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      new_version: ${{ steps.version-bump.outputs.new_version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    strategy:
      matrix:
        service: ${{ fromJson(format('[{0}]', needs.determine-services.outputs.services)) }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Version Bump"
        id: version-bump
        run: |
          # Lire la version actuelle du package.json
          CURRENT_VERSION=$(jq -r '.version' ./${{ matrix.service }}/package.json)
          echo "Current version: $CURRENT_VERSION"

          # Parser la version
          MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
          MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
          PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)

          # Bumper selon le type
          case "${{ github.event.inputs.bump_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

          # Mettre √† jour package.json
          jq ".version = \"$NEW_VERSION\"" ./${{ matrix.service }}/package.json > /tmp/package.json.tmp
          mv /tmp/package.json.tmp ./${{ matrix.service }}/package.json

      - name: "G√©n√©rer Changelog"
        id: changelog
        run: |
          CHANGELOG_FILE="./${{ matrix.service }}/CHANGELOG.md"
          
          # R√©cup√©rer les commits depuis le dernier tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline)
          else
            COMMITS=$(git log $LAST_TAG..HEAD --oneline)
          fi

          # Construire le changelog
          cat > /tmp/changelog.md << EOF
          # ${{ matrix.service }} v${{ steps.version-bump.outputs.new_version }}

          ## Changements

          $(echo "$COMMITS" | sed 's/^/- /')

          ## Date
          $(date -u +'%Y-%m-%d %H:%M:%S UTC')

          EOF

          # Pr√©pendre au changelog existant
          if [ -f "$CHANGELOG_FILE" ]; then
            cat "$CHANGELOG_FILE" >> /tmp/changelog.md
          fi
          
          mv /tmp/changelog.md "$CHANGELOG_FILE"
          cat "$CHANGELOG_FILE" > $GITHUB_OUTPUT

      - name: "Commit & Tag"
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ./${{ matrix.service }}/package.json
          git add ./${{ matrix.service }}/CHANGELOG.md
          
          git commit -m "chore(${{ matrix.service }}): bump version to ${{ steps.version-bump.outputs.new_version }}"
          
          # Cr√©er et pusher le tag
          git tag "${{ matrix.service }}-v${{ steps.version-bump.outputs.new_version }}"
          git push origin main --follow-tags

  # Zero Downtime Deployment
  deploy:
    needs: [build-and-push, version-and-changelog]
    runs-on: ubuntu-latest
    if: success()
    strategy:
      matrix:
        service: ${{ fromJson(format('[{0}]', needs.determine-services.outputs.services)) }}
        # D√©ployer s√©quentiellement pour √©viter les surcharges
      max-parallel: 1
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Rolling Deployment Check"
        id: health-check
        run: |
          echo "V√©rification de la disponibilit√© du service..."
          # Ajouter votre logique de health check ici
          # Exemple pour une API:
          # for i in {1..5}; do
          #   if curl -f https://api.example.com/${{ matrix.service }}/health; then
          #     echo "Service is healthy"
          #     exit 0
          #   fi
          #   sleep 10
          # done
          
          echo "health_status=ready" >> $GITHUB_OUTPUT

      - name: "D√©ployer le service (${{ matrix.service }})"
        if: steps.health-check.outputs.health_status == 'ready'
        run: |
          echo "D√©ploiement de ${{ matrix.service }} v${{ needs.version-and-changelog.outputs.new_version }}"
          
          # Ajouter votre logique de d√©ploiement ici
          # Exemples:
          # - kubectl apply -f deployments/${{ matrix.service }}.yaml
          # - docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.service }}
          # - systemctl restart ${{ matrix.service }}

          echo "D√©ploiement r√©ussi"

      - name: "Post-Deployment Health Check"
        run: |
          echo " V√©rification post-d√©ploiement..."
          sleep 30
          # Ajouter votre logique de v√©rification post-d√©ploiement
          echo "Service op√©rationnel"

  # GitHub Release
  create-release:
    needs: [deploy, version-and-changelog]
    runs-on: ubuntu-latest
    if: success()
    permissions:
      contents: write
    strategy:
      matrix:
        service: ${{ fromJson(format('[{0}]', needs.determine-services.outputs.services)) }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4

      - name: "Cr√©er GitHub Release"
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "${{ matrix.service }}-v${{ needs.version-and-changelog.outputs.new_version }}"
          release_name: "${{ matrix.service }} v${{ needs.version-and-changelog.outputs.new_version }}"
          body: |
            ## Release: ${{ matrix.service }} v${{ needs.version-and-changelog.outputs.new_version }}

            ${{ needs.version-and-changelog.outputs.changelog }}

            ### Images Docker
            - `${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.service }}:v${{ needs.version-and-changelog.outputs.new_version }}`

            ### S√©curit√©
            - CodeQL scan completed
            - Dependabot checked
            - Zero downtime deployment

          draft: false
          prerelease: false

  # R√©capitulatif
  summary:
    needs: [create-release]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: "R√©sum√© du d√©ploiement"
        run: |
          echo "==================================="
          echo "Pipeline CD Termin√©"
          echo "==================================="
          echo "Services d√©ploy√©s: ${{ github.event.inputs.service }}"
          echo "Version bump: ${{ github.event.inputs.bump_type }}"
          echo "Images push√©es vers: ${{ env.REGISTRY }}"
          echo "Tags cr√©√©s et releases publi√©es"
          echo "==================================="
